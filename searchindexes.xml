<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Datastruct</title><url>/me/post/datastruct/</url><categories><category>笔记</category></categories><tags><tag>dataStrucct</tag><tag><no value=/></tags><content type="html"><![CDATA[数据结构笔记 二叉树已更新完毕
[toc]
基础算法汇总 part1 线性表、栈、队列 1.1线性表 顺序表插入元素操作 //初始条件：顺序线性表 L 已存在， 1 ≤ i ≤ ListLength(L) //操作结果：在 L 中第 i 个位置之前插入新的数据元素 e,L 的长度加 1 int ListInsert(SeqList *L,int i,ElemType *e){ int k; if(L-&gt;length == MAXSIZE) //顺序线性表已经满 return ERROR; if (i&lt;1 || i&gt;L-&gt;length+ 1) //当 i 不在范围内时 return ERROR; if( i&lt;=L-&gt;length) {//若插入数据位置不在表尾 //将要插入位置后 的 数据元素向后动一位 for(k=L-&gt;length + 1; k &gt;= i - 1; k--) L -&gt;data[k+1]=L-&gt;data[k]; } L -&gt;data[i+1]=e;//将新元素插入 L-&gt;length ++; return OK; } 在上述代码中，核心语句为for 循环里面的判断，对顺序表进行插入操作，应该先进 行位置移动，然后才能进行插入操 作。所以顺序线性表的插入，时间复杂度为 O(n)。
顺序表按位删除元素操作 初始条件： 顺序线性表 L 已存在， 1 ≤ i ≤ List.Length(L) 操作结果：删除 L 的第 i 个数据元素，并用 e 返回其值， L 的长度减 1 int ListDelete(SqList *L,int i,ElemType *e){ int k; if (L-&gt;length == 0)//线性表为空 return ERROR; if(i&lt;1|| i&gt;L -&gt;length) //删除位置不正确 return ERROR; *e=L-&gt;data[i-1]; if(i != L-&gt;length +1){ //如果删除不是最后位置 for (k=i;k&lt; L-&gt;length;k++) 将删除位置后继元素前移 L-&gt;data[k-1]=L-&gt;data[k]; L -&gt;length--: } return OK; } 该删除算法关键步骤是：从删除元素位置开始遍历到最后一个元素位置，分别依次将它 们向前移动一个位置，然后对第 i 个元素进行删除。 因为在进行删除之前还需要一次跟插入一样的移动操作，故删除的平均算法时间也为 O(n)。 3. 单链表按位查找 初始条件：顺序线性表已存在， 1≤i≤ListLength(L) 操作结果：用 e 返回表中第 i 个数据元素的值
int GetElem(LinkList L,int i,ElemType *e){ int j=1; //j 为计数器 LinkList *p; //声明一 节点p p=L-&gt;next; //p 指向链表 L 的第一个节点 while(p &amp;&amp; j&lt;i) { 当 p 不为空 并且 计数器 不 等于 i 时，循环继续 p=p-&gt;next //p 指向下一个 节点 j++; } if(!p || j &gt; i) return ERROR; *e = p -&gt;data; return OK; } 代码题中记得写上容错机制。 4. 单链表插入操作 初始条件：链表已存在， 1 ≤ i ≤ ListLength L 操作结果： 链表的在第 i 处插入新元素 e
int ListInsert(LinkList *L,int i,ElemType e){ int j=1； LinkList *p,*s; p=L-&gt;next; while (p &amp;&amp; j&lt;i) {//寻找第 i 个 节点 p=p -&gt; next; j++; } if (!p || j&gt;i) return ERROR; //第 i 个元素不存在 s=(LinkList *) malloc (sizeof(Node)) //生成新节点 (C 标准函数） s -&gt;data= e; s -&gt;next=p -&gt;next;// 将 p 的后继节点赋值给 s 的后继 p -&gt;next = s;//将 s 赋值给 p 的后继 return OK; } 链表逆置 方法一： 算法思想：修改指针即可，head 指针遍历链表不断向前移动，用 p 记录 head的之前的一个节点，修改各个节点指针域 next，指向 p，用一个 temp指针指向（保存）head 的下一个节点。 ListNode* reverseList(ListNode* head){ ListNode *temp,*p = NULL; while(head != NULL) { temp = head -&gt;next; head -&gt; next = p; p = head; head = temp; } return p; } 方法二：递归(无头结点代码)
ListNode* reverseList(ListNode* head){ if(head == NULL || head -&gt; next == NULL)//链表为空or只有一个结点 return head; ListNode newhead = reverseList(head -&gt; next);//递归到链尾 head-&gt;next-&gt;next = head;//反转链表 head -&gt; next = NULL; return newhead;//newhead始终指向新链表的头 } 逆置循环双链表（含两个以上节点） 算法思想：只交换节点中的数据成员 data ，其他的前后指针不变。 void Reverse () { swap(_head_ -&gt;_data, _tail_ -&gt;_data); LinkList * begin = _head-&gt;next; LinkList * end = _tail-&gt;prev; //以上为修正后，替换了以下内容 // LinkList * begin = _head; // LinkList * end = _tail; while (begin != end &amp;&amp; begin -&gt;_prev != end) { swap(begin -&gt;_data, end -&gt;_data); begin = begin -&gt;_next; end = end -&gt;_prev; } } part2 KMP part3 树 3.1二叉树遍历 先序遍历 //递归算法 void PreOrder(Bitree T){ if(T != NULL) { visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); } } //非递归算法 void PreOrder(Bitree T){ InitStack(S); BiTree p = T; while(p || !IsEmpty(S)){ if (p){ visit(p); Push(S,p); p = p-&gt;rchild; } else{ Pop{S,p}; p = p-&gt;lchild; } } } 中序遍历 //递归算法 void InOrder(BiTree T){ if (T != NULL){ InOrder(T-&gt;lchild); visit(T); InOrder(T-&gt;rchild); } } //非递归算法 void InOrder(BiTree T){ InitStack(s); BiTree p = T; while(p || IsEmpty(S)){ if(p){ Push(S,p); p = p-&gt;lchild; } else { Pop(S,p); visit p; p = p-&gt;rchild; } } } 后序遍历 //递归算法 void PostOrder(BiTree T){ if(T != NULL){ PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); visit(T); } } //非递归算法 void PostOrder(BiTree T){ InitStack(S); BiTree p = T; BiTree r = NULL; while (p || IsEmpty(S)){ if (p){ Push(S,p); p = p-&gt;lchild; } else { GetTop(S,p); if(p-&gt;rchild &amp;&amp; p-&gt;rchild != r) //p的右子树存在，且未被访问过 p = p-&gt;rchild; else{ Pop(S,p); visit(p); r = p; //记录最近访问过的结点 p = NULL;//结点访问完后，重置p指针 } } } } 层次遍历 void LevelOrder(BiTree T){ InitQueue(S); BiTree p = T; EnQueue(S,p); while(!IsEmpty(S)){ DeQueue(S,p); visit(p); if(p-&gt;lchild) EnQueue(S,p-&gt;lchild); if(p-&gt;rchild) EnQueue(S,p-&gt;rchild); } } 3.2线索二叉树 中序遍历对二叉树线索化（递归） void InThread(ThreadTree &amp;p,ThreadTree &amp;pre){ if(p!=NULL){ InThread(p-&gt;lchild,pre); //递归，线索化左子树 if(p-&gt;lchild == NULL){ p-&gt;lchild = pre; //左子树为空，建立前驱结点 p-&gt;ltag = 1; } if(pre!=NULL&amp;&amp;pre-&gt;rchild == NULL){ pre-&gt;rchild = p; //建立前驱结点的后继结点 pre-&gt;rtag = 1; } pre = p; //标记当前结点为刚刚访问过的结点 InTread(p-&gt;rchild,pre); //递归，线索化右子树 } } void CreateInThread(ThreadTree T){ ThreadTree pre = NULL; if(T!=NULL){ //非空二叉树，线索化 InThread(T,pre); //线索化二叉树 pre-&gt;rchild=NULL; //处理最后一个结点 pre-&gt;rtag = 1; } } 中序线索二叉树的遍历 在对其遍历时，只需要先找到序列里的第一个结点，然后依次找结点的后继，直到后继为空。 中序线索二叉树后继的规律是：若其右标志为“1&quot;,则为线索，指示其后继，否则遍历右子树种第一个访问的结点（右子树最左下的结点）为其后继。 //求中序线索二叉树的中序序列下第一个结点 ThreadNode *Firstnode(ThreadNode *p){ while(p-&gt;ltag == 0) p = p-&gt;lchild; //最左下结点（不一定是叶子结点） return p; } //求中序线索二叉树种结点p在中序序列下的后继 ThreadNode *Nextnode(ThreadNode *p){ if(p-&gt;rtag == 0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild; } void InOrder(ThreadNode *T){ for(ThreadNode *p = Firstnode(T);p!=NULL;p = Nextnode(p)) visit(p); } 3.3二叉排序树与平衡二叉树 二叉排序树的插入 int BST_Insert(BiTree &amp;T,KeyType k){ if(T==NULL){ T == (BiTree)malloc(sizeof(BSTNode)); T -&gt; key =k; T-&gt;lchild = T-&gt;rchilid = NULL; return 1; //返回1，插入成功 } else if(k == T-&gt;key) //树种存在相同关键字结点，插入失败 return 0; else if(k &lt; T-&gt;key) //插入到左子树 return BST_Insert(T-&gt;lchild,k);// BST_Insert(T-&gt;lchild,k); else //插入到右子树 return BST_Insert(T-&gt;rchild,k); } 二叉排序树的构造 void Creat_BST(BiTree &amp;T,KeyType str[],int n){ T=NULL; //初始化T为空树 int i = 0; while(i &lt; n) { //依次将每个关键词插入树中 BST_Insert(T,str[i]); i++; } } 判断二叉树是否为平衡二叉树 算法思想：设置二叉树平衡标记balance，标记返回二叉树bt是否为平衡二叉树，若为平衡二叉树则返回1，否则返回0；h为二叉树bt的高度。采用后序遍历递归算法： 若bt为空，则高度为0，balance=1； 若bt仅有根节点，则高度为1，balance=1； 否则，对bt的左、右边子树执行递归运算，返回左右子树的高度和平衡标记，bt的高度为最高子树的高度+1。若左右子树高度差大于1，则balance=0；若左右子树的高度差小于等于1，且左右子树都平衡时，balance=1，否则balance=0。 void Judge_AVL(BiTree bt,int &amp;balance,int &amp;h){ int bl = 0, br = 0, hl = 0, hr = 0; //左右子树平衡标记和高度 if(T == NULL){ h = 0; balance = 1; } else if(T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL){ h = 1; balance = 1; } else{ Judge_AVL(T-&gt;lchild,bl,hl);//递归判断左子树 Judge_AVL(T-&gt;rchild,br,hr);//递归判断右子树 h = (hl&gt;hr?hl:hr) +1; if (abs(hl - hr)&lt;2&gt;)//若字数高度差的绝对值&lt;2，则看左右子树是否都平衡 balance = bl&amp;&amp;br;//左右子树都平衡时，二叉树平衡 else balance = 0; } } 判断给定二叉树是否二叉排序树 对二叉排序树来说，其中序遍历为一个递增有序序列。因此对给定的二叉排序树进行遍历，始终能保持前一个值比后一个值小，则说明改二叉树时一棵二叉排序树。 KeyType predt = -32767; //predt为全局变量，保村当前结点中序前驱的值，初始值为负无穷 int JudgeBST(BiTree bt){ int bl,br; if (bt == NULL) //空树 return 1; else { bl = JudgeBST(bt -&gt; lchild); if(bl == 0 || predt &gt;= bt-&gt;date) return 0; predt = bt-&gt;data; br = JudgeBST(bt -&gt; rchild); return br; } } 思路2：用先序遍历，每处理一个一个结点，对比其根节点与左右节点的值。 part4 图 4.1图的遍历 深度优先遍历DFS 基本思想：首先从图中某个顶点 v0 出发，访问此顶点，然后依次从 v0 相邻的顶点出发 深度优先遍历，直至图中所有与 v0 路径相通的顶点都被访问了；若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问。可以看出深度优 先遍历是一个递归的过程。这种遍历过程类似树的先序遍历，均是先访问 节点 ，再从该 节点 出发继续向下遍历。 //伪代码 bool visited[Max_Vex];// 定义访问标记数组，为了防止重复访问 void DFSTraverse(Graph G){ for(v=0;v &lt;G.vexnum;v++) visited[v]=false;// 初始化标记数组 for (v=0;v&lt;G.vexnum;++ if(!visited[v]) //如果 v 未被访问，那么从 v 起，开始做深度优先遍历 DFS(G,v); } void DFS(Graph G,int v){ visit(v); visited[v]=true; //定义为已访问 for (w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(! visited[w]) DFS(G,w); } 广度优先遍历 bool visited[Max_Vex];// 定义访问 标记数组 void BFSTraverse(Graph G){ for( i =0;i&lt;G.vexnum;++i) visited[v]=false;// 初始化标记数组 InitQueue(Q);//初始化队列 for (v=0;v&lt;G.vexnum;++v) if(!visited[v])//如果 v 未被访问，那么从 v 起，开始做广度优先遍历 BFS(G,v); } void BFS(Graph G,int v){ visit(v); visited[v]=true;// 定义为已访问 while(!isEmpty(Q)){ DeQueue(Q,v);//顶点v出队列 for (w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]){ visit(w); visited[w]=true; EnQueue(Q,w);//顶点w入队 }//if }//while } part5 查找 part6 排序 折半插入排序 void InsertSort (Sqlist *L){ int i, j, low, high, mid; for(i = 2; i&lt;=L-&gt;length; i++){ L[0] = L[i]; low = 1; high = i-1; while(low&lt;=high){ mid = (low+high)/2; if(L[mid]&gt;L[0]) high = mid -1; else low = mid + 1; } for(j = i-1; j&gt;= high+1; j--){ L[j+1] = L[j]; } L[high+1] = L[0]; } } 希尔排序 void ShellSort(SqList *L){ for(dk = L-&gt;length/2; dk &gt;= 1; dk = dk/2){ for(i=dk+1; i&lt;=L-&gt;length; i++){ if(L[i]&lt;L[i-dk]){ L[0]=L[i]; for(j=j-dk; j&gt;0 &amp;&amp; L[0]&lt;L[j]; j=j-dk){ L[j+dk] = L[j]; } L[j+dk] = L[0]; } } }	} 希尔时间复杂度约为O(n^1.3^) 最坏情况下时间复杂度为O(n^2^) 选择排序 void SelectSort(SqList *L){ for(int i=0; i&lt;L-&gt;length-1; i++){ int min=i; for(int j=i+1; j&lt;L-&gt;length; j++){ if(L[j]&gt;L[min]) min=j; } if(min!=i) swap(L[i],L[min]); } } 冒泡排序 void BubbleSort(SqList *L){ for(int i=0; i&lt;L-&gt;length-1; i++){ int flag = false; for(int j=L-&gt;length-1; j&gt;i; j--){ if(L[j+1]&lt;L[j]){ swap(L[j+1],L[j]); flag = true; } } if(flag==false) return; } } 快速排序-1 void QuickSort(SqList *L,int low, int high){ if(low &lt; high){ int pivotpos=Partition(L,low,high); QucikSort(L,low,pivotops-1); QucikSort(L,pivotops+1,high); } } //划分操作 int Partition(SqList *L,int low, int high){ int pivot = L[low]; while(low&lt;high){ while(low&lt;high &amp;&amp; L[high] &gt;= pivot) high--; L[low] = L[high]; while(low&lt; high &amp;&amp; L[low] &lt;= pivot) low++; L[high] = L[low]; } L[low] = pivot; return low; } 快速排序-2 void QuickSort(SqList *L,int low, int high){ if(low &gt;= high) return; int key, i=low , j=high; key=L[low]; while(i&lt;j){ while(i&lt;j &amp;&amp; L[j]&gt;key) j--; while(i&lt;j &amp;&amp; L[i]&lt;=key) i++; if(i&lt;j) swap(L[i],L[j]); } Swap(L[high],L[i]); QuickSort(L, low, i-1); QuickSort(L, i+1, high); } 堆排序 //建立大根堆 void BuildMaxHeap(SqList *L){ for(int i=L-&gt;length/2; i&gt;0; i--) HeadAdjust(L,i,L-&gt;length); } void HeadAdjust(SqList *L,int k,int len){ L[0]=L[k]; for(int i=2*k; i&lt;=len; i*=2){ if(i&lt;len &amp;&amp; L[i]&lt;L[i+1]) i++; if(L[0]&gt;=L[i]) break; else{ L[k]=L[i]; k=i; } } L[k]=L[0]; } //堆排序 void HeapSort(Sqlist *L){ BuildMaxHeap(L); for(int i=L-&gt;length; i&gt;1; i--){ swap(L[i],L[1]); HeadAdjust(L,1,i-1); } } ]]></content></entry><entry><title>MysqlNote</title><url>/me/post/mysqlnote/</url><categories><category>笔记</category></categories><tags><tag>Mysql</tag><tag>数据库</tag></tags><content type="html"><![CDATA[MysqlNote
[toc]
Mysql自用文档 基础 SQL DDL DDL数据库操作
查询 SHOW DATABASES; SELET DATABASE(); 创建 CREATE DATABASE [IF NOT EXSITS] 数据库名[DEFAULT CHAREST 字符集][COLLATE 排序规则]; 删除 DROP DATABASE [IF EXISTS] 数据库名; 使用 USE 数据库名; DDL表操作
查询 查询当前数据库所有的表 SHOW TABLES; 查询表结构成 DESE 表名; 查询指定表的建表语句 SHOW CREATE TABLE 表名； 创建 数据类型 数值类型 字符串类型 日期类型 修改 增加字段 ALTER TABLE 表名 ADD 字段名 类型（长度）[COMMENT注释][约束]; 修改数据类型 ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度）； 修改字段名和字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型（长度）[COMMENT 注释][约束]; 修改表名 ALTER TABLE 表名 RENAME TO 新表名; 删除字段 ALTER TABLE 表名 DROP 字段名; 删除 删除表 DROP TABLE [IF EXISTS] 表名; 删除指定表，并重新创建该表 TRUNCATE TABLE 表名; DML 添加数据INSERT
给指定字段添加数据 INSERT INTO 表名（字段名1，字段名2，……）VALUES（值1，值2，……）； 给全部字段添加数据 INSERT INTO 表名 VALUES（值1，值2，……）； 批量添加数据 INSERT INTO 表名（字段名1，字段名2，……）VALUES（值1，值2，……），（值1，值2，……），（值1，值2，……）； INSERT INTO 表名 VALUES（值1，值2，……），（值1，值2，……），（值1，值2，……）； 注意： 插入数据时，指定的字段顺序需要与值的顺序是一一对应的。 字符串和日期型数据应该包含在引号中。 插入的数据大小，应该在字段的规定范围内。 修改数据UPDATE
UPDATE 表名 SET 字段名1=值1，字段名2=值2，……[WHERE 条件]; 删除数据DELETE
DELETE FROM 表名 [WHERE 条件]; 注意：
DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。
DELETE语句不能删除某一个字段的值（可以使用UPDATE）
DQL DQL语法 SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数
基本查询
查询多个字段 SELET 字段1，字段2，字段3……FROM 表名； SELECT * FROM 表名； 设置别名 SELECT 字段1[AS别名1],字段2[AS 别名]……FROM 表名； 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名； DCL 管理用户
查询用户 USE mysql; SELECT * FROM user; 创建用户 CREATE USER &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo; IDENTIFIED BY &lsquo;密码&rsquo;； - &lsquo;用户名&rsquo;@&rsquo;%&rsquo;：表示在任意主机 修改用户密码 ALTER USER &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo; IDENTIFIED WITH mysql_native_password BY &lsquo;新密码&rsquo;； 删除用户 DROP USER &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo;； 权限控制
主要权限 查询权限 SHOW GRANTS FOR &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo;； 授予权限 GRANT 权限列表 ON 数据库名.表名 TO &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo;； 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM &lsquo;用户名&rsquo;@&lsquo;主机名&rsquo;； 多个权限之间，使用逗号分隔 授权时，数据库名和表名可以使用*进行统配，代表所有 函数 约束 多表查询 事务 进阶]]></content></entry><entry><title>关于 小郭同学 博客说明</title><url>/me/about.html</url><categories/><tags/><content type="html">小郭同学博客现在启用，请大家多多批评。 大家好，我是正在努力转码的原建筑学生小郭同学。0基础开始使用Hugo搭建个人博客，费了不少精力，拥有自己的博客个人觉得是一个很酷的事情，从现在开始小郭同学会在这里分享一些学习和工作相关的知识，当然可能也会分享一些生活上的事。希望自己不会忘记这建站的喜悦，好好把博客做下去！
我的初心 分享和记录自己学习和工作遇到的问题以及解决方法，督促自己学习的同时将博客做为笔记存放处，如果能够帮到其他人就更好。
感谢素不相识的凡梦星辰提供的NexT主题，也希望这个主题继续在 Hugo 引擎中得到发扬光大</content></entry><entry><title>站点示例</title><url>/me/flinks.html</url><categories/><tags/><content type="html">如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: Hugo-NexT desc: Hugo NexT 官方预览网站。 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png link: https://hugo-next.eu.org</content></entry></search>